// Copyright 2009 The Go Authors. All rights reserved.
//           2016 David Lechner <david@lechnology.com>
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ast declares the types used to represent syntax trees for Go
// packages.
//
package ast

import (
	"github.com/ev3dev/lmsasm/token"
)

// ----------------------------------------------------------------------------
// Interfaces
//
// There are 3 main classes of nodes: Expressions and type nodes,
// statement nodes, and declaration nodes. The node names usually
// match the corresponding Go spec production names to which they
// correspond. The node fields correspond to the individual parts
// of the respective productions.
//
// All nodes contain position information marking the beginning of
// the corresponding source text segment; it is accessible via the
// Pos accessor method. Nodes may contain additional position info
// for language constructs where comments may be found between parts
// of the construct (typically any larger, parenthesized subpart).
// That position information is needed to properly position comments
// when printing the construct.

// All node types implement the Node interface.
type Node interface {
	Pos() token.Pos // position of first character belonging to the node
	End() token.Pos // position of first character immediately after the node
}

// All expression nodes implement the Expr interface.
type Expr interface {
	Node
	exprNode()
}

// All statement nodes implement the Stmt interface.
type Stmt interface {
	Node
	stmtNode()
}

// All declaration nodes implement the Decl interface.
type Decl interface {
	Node
	declNode()
}

// ----------------------------------------------------------------------------
// Expressions and types

// An expression is represented by a tree consisting of one
// or more of the following concrete expression nodes.
//
type (
	// A BadExpr node is a placeholder for expressions containing
	// syntax errors for which no correct expression nodes can be
	// created.
	//
	BadExpr struct {
		From, To token.Pos // position range of bad expression
	}

	// An Ident node represents an identifier.
	Ident struct {
		NamePos token.Pos // identifier position
		Name    string    // identifier name
		Obj     *Object   // denoted object; or nil
	}

	// A BasicLit node represents a literal of basic type.
	BasicLit struct {
		ValuePos token.Pos   // literal position
		Kind     token.Token // token.INT, token.FLOAT, or token.STRING
		Value    string      // literal string; e.g. 42, 0x7f, 3.14F or 'foo'
	}

	// A ParenExpr node represents a parenthesized expression.
	ParenExpr struct {
		Lparen token.Pos // position of "("
		X      Expr      // parenthesized expression
		Rparen token.Pos // position of ")"
	}

	// A UnaryExpr node represents a unary expression.
	UnaryExpr struct {
		OpPos token.Pos   // position of Op
		Op    token.Token // operator
		X     Expr        // operand
	}

	// A BinaryExpr node represents a binary expression.
	BinaryExpr struct {
		X     Expr        // left operand
		OpPos token.Pos   // position of Op
		Op    token.Token // operator
		Y     Expr        // right operand
	}
)

// Pos and End implementations for expression/type nodes.

func (x *BadExpr) Pos() token.Pos    { return x.From }
func (x *Ident) Pos() token.Pos      { return x.NamePos }
func (x *BasicLit) Pos() token.Pos   { return x.ValuePos }
func (x *ParenExpr) Pos() token.Pos  { return x.Lparen }
func (x *UnaryExpr) Pos() token.Pos  { return x.OpPos }
func (x *BinaryExpr) Pos() token.Pos { return x.X.Pos() }

func (x *BadExpr) End() token.Pos    { return x.To }
func (x *Ident) End() token.Pos      { return token.Pos(int(x.NamePos) + len(x.Name)) }
func (x *BasicLit) End() token.Pos   { return token.Pos(int(x.ValuePos) + len(x.Value)) }
func (x *ParenExpr) End() token.Pos  { return x.Rparen + 1 }
func (x *UnaryExpr) End() token.Pos  { return x.X.End() }
func (x *BinaryExpr) End() token.Pos { return x.Y.End() }

// exprNode() ensures that only expression/type nodes can be
// assigned to an Expr.
//
func (*BadExpr) exprNode()    {}
func (*Ident) exprNode()      {}
func (*BasicLit) exprNode()   {}
func (*ParenExpr) exprNode()  {}
func (*UnaryExpr) exprNode()  {}
func (*BinaryExpr) exprNode() {}

// ----------------------------------------------------------------------------
// Convenience functions for Idents

// NewIdent creates a new Ident without position.
// Useful for ASTs generated by code other than the Go parser.
//
func NewIdent(name string) *Ident { return &Ident{token.NoPos, name, nil} }

func (id *Ident) String() string {
	if id != nil {
		return id.Name
	}
	return "<nil>"
}

// ----------------------------------------------------------------------------
// Statements

// A statement is represented by a tree consisting of one
// or more of the following concrete statement nodes.
//
type (
	// A BadStmt node is a placeholder for statements containing
	// syntax errors for which no correct statement nodes can be
	// created.
	//
	BadStmt struct {
		From, To token.Pos // position range of bad statement
	}

	// A DeclStmt node represents a declaration in a statement list.
	DeclStmt struct {
		Decl Decl // *GenDecl with CONST, TYPE, or VAR token
	}

	// An EmptyStmt node represents an empty statement.
	// The "position" of the empty statement is the position
	// of the immediately following (explicit or implicit) semicolon.
	//
	EmptyStmt struct {
		Semicolon token.Pos // position of following ";"
		Implicit  bool      // if set, ";" was omitted in the source
	}

	// A LabeledStmt node represents a labeled statement.
	LabeledStmt struct {
		Label *Ident
		Colon token.Pos // position of ":"
		Stmt  Stmt
	}

	// An CallStmt node represents an opcode call
	//
	CallStmt struct {
		Op     *Ident    // opcode identifier
		Lparen token.Pos // position of "("
		Args   []Expr    // function arguments; or nil
		Rparen token.Pos // position of ")"
	}
)

// Pos and End implementations for statement nodes.

func (s *BadStmt) Pos() token.Pos     { return s.From }
func (s *DeclStmt) Pos() token.Pos    { return s.Decl.Pos() }
func (s *EmptyStmt) Pos() token.Pos   { return s.Semicolon }
func (s *LabeledStmt) Pos() token.Pos { return s.Label.Pos() }
func (s *CallStmt) Pos() token.Pos    { return s.Op.Pos() }

func (s *BadStmt) End() token.Pos  { return s.To }
func (s *DeclStmt) End() token.Pos { return s.Decl.End() }
func (s *EmptyStmt) End() token.Pos {
	if s.Implicit {
		return s.Semicolon
	}
	return s.Semicolon + 1 /* len(";") */
}
func (s *LabeledStmt) End() token.Pos { return s.Stmt.End() }
func (s *CallStmt) End() token.Pos    { return s.Rparen }

// stmtNode() ensures that only statement nodes can be
// assigned to a Stmt.
//
func (*BadStmt) stmtNode()     {}
func (*DeclStmt) stmtNode()    {}
func (*EmptyStmt) stmtNode()   {}
func (*LabeledStmt) stmtNode() {}
func (*CallStmt) stmtNode()    {}

// ----------------------------------------------------------------------------
// Declarations

// A Spec node represents a single (non-parenthesized) import,
// constant, type, or variable declaration.
//
type (
	// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.
	Spec interface {
		Node
		specNode()
	}

	// An ImportSpec node represents a single package import.
	DefineSpec struct {
		Name  *Ident // define name
		Value Expr   // value
	}

	// A ValueSpec node represents a variable declaration.
	ValueSpec struct {
		Type   token.ValueType // value type
		Name   *Ident          // value name
		Length Expr            // length or nil
	}

	// A ParamSpec node represents a parameter declaration.
	ParamSpec struct {
		Type   token.ParamType // (IN|OUT|IO)_(8|16|32|F|S)
		Name   *Ident          // type name
		Length Expr            // length or nil
	}
)

// Pos and End implementations for spec nodes.

func (s *DefineSpec) Pos() token.Pos { return s.Name.Pos() }
func (s *ValueSpec) Pos() token.Pos  { return s.Name.Pos() }
func (s *ParamSpec) Pos() token.Pos  { return s.Name.Pos() }

func (s *DefineSpec) End() token.Pos { return s.Value.End() }
func (s *ValueSpec) End() token.Pos {
	if s.Length != nil {
		return s.Length.End()
	}
	return s.Name.End()
}
func (s *ParamSpec) End() token.Pos {
	if s.Length != nil {
		return s.Length.End()
	}
	return s.Name.End()
}

// specNode() ensures that only spec nodes can be
// assigned to a Spec.
//
func (*DefineSpec) specNode() {}
func (*ValueSpec) specNode()  {}
func (*ParamSpec) specNode()  {}

// A declaration is represented by one of the following declaration nodes.
//
type (
	// A BadDecl node is a placeholder for declarations containing
	// syntax errors for which no correct declaration nodes can be
	// created.
	//
	BadDecl struct {
		From, To token.Pos // position range of bad declaration
	}

	// A GenDecl node (generic declaration node) represents a define,
	// variable or parameter declaration.
	//
	// Relationship between Tok value and Specs element type:
	//
	//	token.DEFINE  *DefineSpec
	//	token.VAR     *ValueSpec
	//	token.PARAM   *ParamSpec
	//
	GenDecl struct {
		TokPos token.Pos   // position of Tok
		Tok    token.Token // DEFINE, DATATYPE, PARAMTYPE
		Spec   Spec
	}

	// A ObjDecl node represents a function declaration.
	ObjDecl struct {
		Scope      *Scope      // local scope
		TokPos     token.Pos   // position of Tok
		Tok        token.Token // VMTHREAD, SUBCALL
		Name       *Ident
		Index      int32
		ParamCount uint8
		Body       []Stmt // function body
	}
)

type ObjType byte

// Pos and End implementations for declaration nodes.

func (d *BadDecl) Pos() token.Pos { return d.From }
func (d *GenDecl) Pos() token.Pos { return d.TokPos }
func (d *ObjDecl) Pos() token.Pos { return d.TokPos }

func (d *BadDecl) End() token.Pos { return d.To }
func (d *GenDecl) End() token.Pos { return d.Spec.End() }
func (d *ObjDecl) End() token.Pos { return d.Body[len(d.Body)-1].End() }

// declNode() ensures that only declaration nodes can be
// assigned to a Decl.
//
func (*BadDecl) declNode() {}
func (*GenDecl) declNode() {}
func (*ObjDecl) declNode() {}

// ----------------------------------------------------------------------------
// Files and packages

// A File node represents a lms source file.
//
type File struct {
	Decls      []Decl   // top-level declarations; or nil
	Scope      *Scope   // package scope (this file only)
	Unresolved []*Ident // unresolved identifiers in this file
}

func (f *File) Pos() token.Pos { return 0 }
func (f *File) End() token.Pos {
	if n := len(f.Decls); n > 0 {
		return f.Decls[n-1].End()
	}
	return 0
}
